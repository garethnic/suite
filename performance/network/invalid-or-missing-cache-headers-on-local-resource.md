Caching allows the users browser to keep a local copy of a resource for fast loading without downloading the entire resource from the server every time.

At a minimum a check is run to check for a ``max-age`` or ``expires`` that is expected to be atleast 2 days long, at **minimum**.

Ideally this cache would set to a even longer period, like a few months/years.

See [missing cache headers on local asset](http://passmarked.com/performance/inspect/missing-cache-headers-on-local-asset) for detailed information on setting cache headers that will be able to control how long these headers are set.

# Long Lived Caching

For static resources it's best practice to cache for long periods of time such as a year.

This is advised as you don't want users to repeat downloading files if they have visited that corrosponding version of your app again.

If nothing has changed you do not want users having to download any files again. Saving you and users valuable bandwidth.

# Cache Busting

"**Cache busting**" as it is refered to is the process of adding a either randomly generated or timestamp key to a file name or adding a key to the query string of a file that will allow versioning around the long cache.

For example javascript might be named ``/js/app.js``. Which if cached for a long time will cause clients to not receive updates. 

There are a few options that are at our disposal:

## 1. Appended UID

Best practice is to append a key to a filename that is generated by tools such as [Gulp](http://gulpjs.com/) and [Grunt](http://gruntjs.com/), or any other build tool.

When these tools are used to build, a **hash** for the build is generated either as a [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) or a [timestamp](https://en.wikipedia.org/wiki/Timestamp). 

If the build is for production this **hash** is appended to the filename.

For example output files might be named:

```
app.js
vendor.js
```

Then UID is then appended as part of the build for production:

```
app.098f6bcd4621d373cade4e832627b4f6.min.js
vendor.098f6bcd4621d373cade4e832627b4f6.min.js
```

This allows browsers to cache that version of the app till a new one is built and uploaded to the server.

## 2. Arbitrary Versioning

The easy way lots of users take around cache busting is to simply add a "version" of their choosing to the url.

For example:

```
example.org/js/app.js
```

could be busted from cache by simply adding a ``?version=0.0.1``. The allow you to invalid a users cache as you commit new versions.

When a new version is created that you want users to download the query string key is changed to say ``?version=0.0.2``.

This will then invalidate clients who have older resources cached as they will now be looking for a different file named:

```
example.org/js/app.js?version=0.0.2
```

One example of systems using this method would be [Wordpress](https://wordpress.org/) that appends the current version of [Wordpress](https://wordpress.org/) to the CSS and JS for the WP Dashboard. 

# Resources

* [gulpjs.com](http://gulpjs.com/)
* [gruntjs.com](http://gruntjs.com/)
* [en.wikipedia.org/wiki/Universally_unique_identifier](https://en.wikipedia.org/wiki/Universally_unique_identifier)
* [en.wikipedia.org/wiki/Timestamp](https://en.wikipedia.org/wiki/Timestamp)